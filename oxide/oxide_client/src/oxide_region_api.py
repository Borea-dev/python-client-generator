# generated by borea

# if you want to edit this file, add it to ignores in borea.config.json, glob syntax

from typing import Any, Callable, Dict, Optional
import httpx
from ..models.models import *

from .disks.disks import Disks
from .floating_ips.floating_ips import FloatingIps
from .hidden.hidden import Hidden
from .images.images import Images
from .instances.instances import Instances
from .login.login import Login
from .metrics.metrics import Metrics
from .policy.policy import Policy
from .projects.projects import Projects
from .roles.roles import Roles
from .session.session import Session
from .silos.silos import Silos
from .snapshots.snapshots import Snapshots
from .system_hardware.system_hardware import SystemHardware
from .system_ip_pools.system_ip_pools import SystemIpPools
from .system_metrics.system_metrics import SystemMetrics
from .system_networking.system_networking import SystemNetworking
from .system_silos.system_silos import SystemSilos
from .system_status.system_status import SystemStatus
from .vpcs.vpcs import Vpcs


class OxideRegionAPI:
    def __init__(
        self,
        base_url: str = "",
        api_key: Optional[str] = None,
        timeout: float = 10.0,
        before_request: Optional[Callable[[httpx.Request], None]] = None,
        after_request: Optional[Callable[[httpx.Response], None]] = None,
    ):
        """
        Oxide Region API

        API for interacting with the Oxide control plane

        Args:
            base_url: The base URL for API requests
            api_key: Optional API key for authentication
            timeout: Request timeout in seconds
            before_request: Optional callback before each request
            after_request: Optional callback after each request
        """
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.timeout = timeout
        self.before_request = before_request
        self.after_request = after_request
        self.client = httpx.Client(timeout=timeout)

        if api_key:
            self.client.headers.update({"Authorization": f"Bearer {api_key}"})

        self.disks = Disks(parent=self)
        self.floating_ips = FloatingIps(parent=self)
        self.hidden = Hidden(parent=self)
        self.images = Images(parent=self)
        self.instances = Instances(parent=self)
        self.login = Login(parent=self)
        self.metrics = Metrics(parent=self)
        self.policy = Policy(parent=self)
        self.projects = Projects(parent=self)
        self.roles = Roles(parent=self)
        self.session = Session(parent=self)
        self.silos = Silos(parent=self)
        self.snapshots = Snapshots(parent=self)
        self.system_hardware = SystemHardware(parent=self)
        self.system_ip_pools = SystemIpPools(parent=self)
        self.system_metrics = SystemMetrics(parent=self)
        self.system_networking = SystemNetworking(parent=self)
        self.system_silos = SystemSilos(parent=self)
        self.system_status = SystemStatus(parent=self)
        self.vpcs = Vpcs(parent=self)

    def _make_request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        json_data: Optional[Dict[str, Any]] = None,
    ) -> httpx.Response:
        """Make an HTTP request.

        Args:
            method: HTTP method
            path: Request path
            params: Query parameters
            headers: Additional request headers
            json_data: JSON request body

        Returns:
            httpx.Response: The response from the server
        """
        url = f"{self.base_url}/{path.lstrip('/')}"

        # Merge any additional headers with existing ones
        request_headers = self.client.headers.copy()
        if headers:
            request_headers.update(headers)

        request = self.client.build_request(
            method=method,
            url=url,
            params=params,
            headers=request_headers,
            json=json_data,
        )

        if self.before_request:
            self.before_request(request)

        response = self.client.send(request)

        if self.after_request:
            self.after_request(response)

        response.raise_for_status()
        return response

    def close(self):
        """Close the HTTP client."""
        self.client.close()
