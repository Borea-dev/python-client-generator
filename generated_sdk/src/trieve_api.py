# generated by borea

# if you want to edit this file, add it to ignores in borea.config.json, glob syntax

from typing import Any, Callable, Dict, Optional
import httpx
from ..models.models import *

from .analytics.analytics_handler import Analytics
from .auth.auth_handler import Auth
from .chunk.chunk_handler import Chunk
from .chunk_group.chunk_group_handler import ChunkGroup
from .crawl.crawl_handler import Crawl
from .dataset.dataset_handler import Dataset
from .file.file_handler import File
from .health.health_handler import Health
from .invitation.invitation_handler import Invitation
from .message.message_handler import Message
from .organization.organization_handler import Organization
from .public.public_handler import Public
from .stripe.stripe_handler import Stripe
from .topic.topic_handler import Topic
from .user.user_handler import User
from .metrics.metrics_handler import Metrics


class TrieveApi:
    def __init__(
        self,
        base_url: str = "https://api.trieve.ai",
        api_key: Optional[str] = None,
        timeout: float = 10.0,
        before_request: Optional[Callable[[httpx.Request], None]] = None,
        after_request: Optional[Callable[[httpx.Response], None]] = None,
    ):
        """
        Trieve API

        Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.

        Args:
            base_url: The base URL for API requests
            api_key: Optional API key for authentication
            timeout: Request timeout in seconds
            before_request: Optional callback before each request
            after_request: Optional callback after each request
        """
        self.base_url = base_url.rstrip("/")
        self.api_key = api_key
        self.timeout = timeout
        self.before_request = before_request
        self.after_request = after_request
        self.client = httpx.Client(timeout=timeout)

        if api_key:
            self.client.headers.update({"Authorization": f"Bearer {api_key}"})
        self.client.headers.update({"TR-Dataset": ""})
        self.client.headers.update({"TR-Organization": ""})
        self.client.headers.update({"X-API-Version": ""})

        self.analytics = Analytics(self)
        self.auth = Auth(self)
        self.chunk = Chunk(self)
        self.chunk_group = ChunkGroup(self)
        self.crawl = Crawl(self)
        self.dataset = Dataset(self)
        self.file = File(self)
        self.health = Health(self)
        self.invitation = Invitation(self)
        self.message = Message(self)
        self.organization = Organization(self)
        self.public = Public(self)
        self.stripe = Stripe(self)
        self.topic = Topic(self)
        self.user = User(self)
        self.metrics = Metrics(self)

    def _make_request(
        self,
        method: str,
        path: str,
        params: Optional[Dict[str, Any]] = None,
        headers: Optional[Dict[str, str]] = None,
        json_data: Optional[Dict[str, Any]] = None,
    ) -> httpx.Response:
        """Make an HTTP request.

        Args:
            method: HTTP method
            path: Request path
            params: Query parameters
            headers: Additional request headers
            json_data: JSON request body

        Returns:
            httpx.Response: The response from the server
        """
        url = f"{self.base_url}/{path.lstrip('/')}"

        # Merge any additional headers with existing ones
        request_headers = self.client.headers.copy()
        if headers:
            request_headers.update(headers)

        request = self.client.build_request(
            method=method,
            url=url,
            params=params,
            headers=request_headers,
            json=json_data,
        )

        if self.before_request:
            self.before_request(request)

        response = self.client.send(request)

        if self.after_request:
            self.after_request(response)

        response.raise_for_status()
        return response

    def close(self):
        """Close the HTTP client."""
        self.client.close()
