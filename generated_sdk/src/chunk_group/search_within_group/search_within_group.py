# generated by borea

# if you want to edit this file, add it to ignores in borea.config.json, glob syntax

# TODO: not implemented

from typing import Any, Dict, List, Optional, Union, TYPE_CHECKING
from ....models.models import *

if TYPE_CHECKING:
    from ...trieve_api import TrieveApi


class SearchWithinGroup:
    def __init__(self, parent: "TrieveApi"):
        self.parent = parent

    def search_within_group(
        self,
        tr_dataset: str,
        query: QueryTypes,
        search_type: SearchMethod,
        x_api_version: Optional[APIVersion] = None,
        content_only: Optional[bool] = None,
        filters: Optional[ChunkFilter] = None,
        get_total_pages: Optional[bool] = None,
        group_id: Optional[str] = None,
        group_tracking_id: Optional[str] = None,
        highlight_options: Optional[HighlightOptions] = None,
        page: Optional[int] = None,
        page_size: Optional[int] = None,
        remove_stop_words: Optional[bool] = None,
        score_threshold: Optional[float] = None,
        slim_chunks: Optional[bool] = None,
        sort_options: Optional[SortOptions] = None,
        typo_options: Optional[TypoOptions] = None,
        use_quote_negated_terms: Optional[bool] = None,
        user_id: Optional[str] = None,
    ) -> Any:
        """
        This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using scores from a cross encoder model.

        Args:
            tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
            query: No description provided
            search_type: No description provided
            x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
            content_only: Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
            filters: ChunkFilter is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.
            get_total_pages: Get total page count for the query accounting for the applied filters. Defaults to false, but can be set to true when the latency penalty is acceptable (typically 50-200ms).
            group_id: Group specifies the group to search within. Results will only consist of chunks which are bookmarks within the specified group.
            group_tracking_id: Group_tracking_id specifies the group to search within by tracking id. Results will only consist of chunks which are bookmarks within the specified group. If both group_id and group_tracking_id are provided, group_id will be used.
            highlight_options: Highlight Options lets you specify different methods to highlight the chunks in the result set. If not specified, this defaults to the score of the chunks.
            page: The page of chunks to fetch. Page is 1-indexed.
            page_size: The page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
            remove_stop_words: If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
            score_threshold: Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
            slim_chunks: Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.
            sort_options: Sort Options lets you specify different methods to rerank the chunks in the result set. If not specified, this defaults to the score of the chunks.
            typo_options: Typo Options lets you specify different methods to correct typos in the query. If not specified, typos will not be corrected.
            use_quote_negated_terms: If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
            user_id: The user_id is the id of the user who is making the request. This is used to track user interactions with the search results.

        Returns:
            Response data
        """
        path = f"/api/chunk_group/search"
        params = {}
        headers = {}
        if tr_dataset is not None:
            headers["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            headers["X-API-Version"] = x_api_version
        json_data = {
            "content_only": content_only if content_only is not None else None,
            "filters": filters if filters is not None else None,
            "get_total_pages": get_total_pages if get_total_pages is not None else None,
            "group_id": group_id if group_id is not None else None,
            "group_tracking_id": (
                group_tracking_id if group_tracking_id is not None else None
            ),
            "highlight_options": (
                highlight_options if highlight_options is not None else None
            ),
            "page": page if page is not None else None,
            "page_size": page_size if page_size is not None else None,
            "query": query if query is not None else None,
            "remove_stop_words": (
                remove_stop_words if remove_stop_words is not None else None
            ),
            "score_threshold": score_threshold if score_threshold is not None else None,
            "search_type": search_type if search_type is not None else None,
            "slim_chunks": slim_chunks if slim_chunks is not None else None,
            "sort_options": sort_options if sort_options is not None else None,
            "typo_options": typo_options if typo_options is not None else None,
            "use_quote_negated_terms": (
                use_quote_negated_terms if use_quote_negated_terms is not None else None
            ),
            "user_id": user_id if user_id is not None else None,
        }
        json_data = {k: v for k, v in json_data.items() if v is not None}

        response = self.parent._make_request(
            method="POST",
            path=path,
            params=params,
            headers=headers,
            json_data=json_data,
        )
        return response.json()
