# generated by borea

# if you want to edit this file, add it to ignores in borea.config.json, glob syntax

# TODO: not implemented

from typing import Any, Dict, List, Optional, Union, TYPE_CHECKING
from ....models.models import *

if TYPE_CHECKING:
    from ...trieve_api import TrieveApi


class GetRecommendedGroups:
    def __init__(self, parent: "TrieveApi"):
        self.parent = parent

    def get_recommended_groups(
        self,
        tr_dataset: str,
        x_api_version: Optional[APIVersion] = None,
        filters: Optional[ChunkFilter] = None,
        group_size: Optional[int] = None,
        limit: Optional[int] = None,
        negative_group_ids: Optional[List[str]] = None,
        negative_group_tracking_ids: Optional[List[str]] = None,
        positive_group_ids: Optional[List[str]] = None,
        positive_group_tracking_ids: Optional[List[str]] = None,
        recommend_type: Optional[RecommendType] = None,
        slim_chunks: Optional[bool] = None,
        strategy: Optional[RecommendationStrategy] = None,
        user_id: Optional[str] = None,
    ) -> Any:
        """
        Route to get recommended groups. This route will return groups which are similar to the groups in the request body. You must provide at least one positive group id or group tracking id.

        Args:
            tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
            x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
            filters: ChunkFilter is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.
            group_size: The number of chunks to fetch for each group. This is the number of chunks which will be returned in the response for each group. The default is 3. If this is set to a large number, we recommend setting slim_chunks to true to avoid returning the content and chunk_html of the chunks so as to reduce latency due to content download and serialization.
            limit: The number of groups to return. This is the number of groups which will be returned in the response. The default is 10.
            negative_group_ids: The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.
            negative_group_tracking_ids: The ids of the groups to be used as negative examples for the recommendation. The groups in this array will be used to filter out similar groups.
            positive_group_ids: The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.
            positive_group_tracking_ids: The ids of the groups to be used as positive examples for the recommendation. The groups in this array will be used to find similar groups.
            recommend_type: The type of recommendation to make. This lets you choose whether to recommend based off of `semantic` or `fulltext` similarity. The default is `semantic`.
            slim_chunks: Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typicall 10-50ms). Default is false.
            strategy: Strategy to use for recommendations, either "average_vector" or "best_score". The default is "average_vector". The "average_vector" strategy will construct a single average vector from the positive and negative samples then use it to perform a pseudo-search. The "best_score" strategy is more advanced and navigates the HNSW with a heuristic of picking edges where the point is closer to the positive samples than it is the negatives.
            user_id: The user_id is the id of the user who is making the request. This is used to track user interactions with the rrecommendation results.

        Returns:
            Response data
        """
        path = f"/api/chunk_group/recommend"
        params = {}
        headers = {}
        if tr_dataset is not None:
            headers["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            headers["X-API-Version"] = x_api_version
        json_data = {
            "filters": filters if filters is not None else None,
            "group_size": group_size if group_size is not None else None,
            "limit": limit if limit is not None else None,
            "negative_group_ids": (
                negative_group_ids if negative_group_ids is not None else None
            ),
            "negative_group_tracking_ids": (
                negative_group_tracking_ids
                if negative_group_tracking_ids is not None
                else None
            ),
            "positive_group_ids": (
                positive_group_ids if positive_group_ids is not None else None
            ),
            "positive_group_tracking_ids": (
                positive_group_tracking_ids
                if positive_group_tracking_ids is not None
                else None
            ),
            "recommend_type": recommend_type if recommend_type is not None else None,
            "slim_chunks": slim_chunks if slim_chunks is not None else None,
            "strategy": strategy if strategy is not None else None,
            "user_id": user_id if user_id is not None else None,
        }
        json_data = {k: v for k, v in json_data.items() if v is not None}

        response = self.parent._make_request(
            method="POST",
            path=path,
            params=params,
            headers=headers,
            json_data=json_data,
        )
        return response.json()
