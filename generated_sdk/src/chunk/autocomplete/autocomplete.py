# generated by borea

# if you want to edit this file, add it to ignores in borea.config.json, glob syntax

# TODO: not implemented

from typing import Any, Dict, List, Optional, Union, TYPE_CHECKING
from ....models.models import *

if TYPE_CHECKING:
    from ...trieve_api import TrieveApi


class Autocomplete:
    def __init__(self, parent: "TrieveApi"):
        self.parent = parent

    def autocomplete(
        self,
        tr_dataset: str,
        query: SearchModalities,
        search_type: SearchMethod,
        x_api_version: Optional[APIVersion] = None,
        content_only: Optional[bool] = None,
        extend_results: Optional[bool] = None,
        filters: Optional[ChunkFilter] = None,
        highlight_options: Optional[HighlightOptions] = None,
        page_size: Optional[int] = None,
        remove_stop_words: Optional[bool] = None,
        score_threshold: Optional[float] = None,
        scoring_options: Optional[ScoringOptions] = None,
        slim_chunks: Optional[bool] = None,
        sort_options: Optional[SortOptions] = None,
        typo_options: Optional[TypoOptions] = None,
        use_quote_negated_terms: Optional[bool] = None,
        user_id: Optional[str] = None,
    ) -> Any:
        """
        This route provides the primary autocomplete functionality for the API. This prioritize prefix matching with semantic or full-text search.

        Args:
            tr_dataset: The dataset id or tracking_id to use for the request. We assume you intend to use an id if the value is a valid uuid.
            query: No description provided
            search_type: No description provided
            x_api_version: The API version to use for this request. Defaults to V2 for orgs created after July 12, 2024 and V1 otherwise.
            content_only: Set content_only to true to only returning the chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
            extend_results: If specified to true, this will extend the search results to include non-exact prefix matches of the same search_type such that a full page_size of results are returned. Default is false.
            filters: ChunkFilter is a JSON object which can be used to filter chunks. This is useful for when you want to filter chunks by arbitrary metadata. Unlike with tag filtering, there is a performance hit for filtering on metadata.
            highlight_options: Highlight Options lets you specify different methods to highlight the chunks in the result set. If not specified, this defaults to the score of the chunks.
            page_size: Page size is the number of chunks to fetch. This can be used to fetch more than 10 chunks at a time.
            remove_stop_words: If true, stop words (specified in server/src/stop-words.txt in the git repo) will be removed. Queries that are entirely stop words will be preserved.
            score_threshold: Set score_threshold to a float to filter out chunks with a score below the threshold. This threshold applies before weight and bias modifications. If not specified, this defaults to 0.0.
            scoring_options: Scoring options provides ways to modify the sparse or dense vector created for the query in order to change how potential matches are scored. If not specified, this defaults to no modifications.
            slim_chunks: Set slim_chunks to true to avoid returning the content and chunk_html of the chunks. This is useful for when you want to reduce amount of data over the wire for latency improvement (typically 10-50ms). Default is false.
            sort_options: Sort Options lets you specify different methods to rerank the chunks in the result set. If not specified, this defaults to the score of the chunks.
            typo_options: Typo Options lets you specify different methods to correct typos in the query. If not specified, typos will not be corrected.
            use_quote_negated_terms: If true, quoted and - prefixed words will be parsed from the queries and used as required and negated words respectively. Default is false.
            user_id: User ID is the id of the user who is making the request. This is used to track user interactions with the search results.

        Returns:
            Response data
        """
        path = f"/api/chunk/autocomplete"
        params = {}
        headers = {}
        if tr_dataset is not None:
            headers["TR-Dataset"] = tr_dataset
        if x_api_version is not None:
            headers["X-API-Version"] = x_api_version
        json_data = {
            "content_only": content_only if content_only is not None else None,
            "extend_results": extend_results if extend_results is not None else None,
            "filters": filters if filters is not None else None,
            "highlight_options": (
                highlight_options if highlight_options is not None else None
            ),
            "page_size": page_size if page_size is not None else None,
            "query": query if query is not None else None,
            "remove_stop_words": (
                remove_stop_words if remove_stop_words is not None else None
            ),
            "score_threshold": score_threshold if score_threshold is not None else None,
            "scoring_options": scoring_options if scoring_options is not None else None,
            "search_type": search_type if search_type is not None else None,
            "slim_chunks": slim_chunks if slim_chunks is not None else None,
            "sort_options": sort_options if sort_options is not None else None,
            "typo_options": typo_options if typo_options is not None else None,
            "use_quote_negated_terms": (
                use_quote_negated_terms if use_quote_negated_terms is not None else None
            ),
            "user_id": user_id if user_id is not None else None,
        }
        json_data = {k: v for k, v in json_data.items() if v is not None}

        response = self.parent._make_request(
            method="POST",
            path=path,
            params=params,
            headers=headers,
            json_data=json_data,
        )
        return response.json()
